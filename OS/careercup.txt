https://www.careercup.com/page?pid=operating-system-interview-questions


Linux has nice commands called "tree". Given filename and initial dire list all file paths which matches the filename. also allow regex match.

wc filename: char count, word count, line count of file
implement your own wc

consider disk drive w/ 16 platters, 2 surfaces, 512 tracks, 2K sectors, and 4KB pages. what is capacity of disk drive in terms of bytes?

semaphore 
P = down = decrement
V = up = increment

init to +17. 23P, 18V, 16P, 14V, 1P
17 - 23 + 18 - 16 + 14 - 1 = -6 +2 + 13 = +9


virtual memory can be handled by both (a) demand paging and (b) demand segmentation.
demand paging = special case of segmentation with segment size = 1 page.
in demand paging, we divide logical addr space into same page size
in segmentation, we divide jobs into segments


difference between crash and exception. exceptions are defined situations in which c++ can manage and handle. Some undefined exceptions such as null ptr dereferencing are not handled by exceptions which causes the program to crash


difference between interrupt and exception
interrupt -> outside process affects current process which affects current execution path
exception -> occurs within process affects current execution path

interrupt is an asynchronous event that is typically generated by HW (I/O) not in synch with processor instruction execution
exceptions (SW interrupts) are synchronous events generated when processor detects any predefined condition while executing instruction

interrupt handler may be interrupted by another interrupt handler.
interrupt handler may defer an exception handler but an exception handler never defers to an interrupt handler. The only exception possible in kernel mode is the page fault.


**difference between macros and inline functions. (C++)**
inline replaces a call to a function with the body of a function. 
a macro is expanded by the preprocessor before compilation. just like text substitution. macros are not type checked. but inline functions are. 


late binding is a runtime process of looking up a declaration by name that corresponds to a uniquely specified type. It does not involve type checking during compilation. the term 'dynamically linked' means that the program and the particular library it references are not combined together by the linker at the link time. 

disadv of late binding
- slowed application performance
- does not provide code completion benefits

generally used in scenarios where an exact object interface is unknown at design time

early binding: term "statically linked" means that program and particular library that it's linked against are combined together by the linker at link time


Java runs on a "virtual" stack machine inside JVM which has instruction of size of 1 byte (called byte-codes). How many instructions/bytecodes potentially can such a machine have?
>> 256. Does not depend on stack, OS, or JVM
>> because there are 256 possible values of a byte. of 256 possible, 198 in current use, 51 are reserved for future use, 3 are set aside permanently unimplemented


If you run the same program 2x, what section would be shared in the memory?
>> physical pages associated with shared libraries and text segment are mapped into virtual address space of both processes. pages that are copy-on-write until modifiedplsu any explicitly shared memory segments as well - mmap()



What is the following program trying to do?


#define SIZE (1<<;31) // 2 Gb

int main()
{
	char *p=malloc(SIZE);
	memset(p, 0, SIZE);
}
a. Trying to crash OS by allocating lot of memory 
b. Trying to calculate amount of system memory 
c. Trying to allocate virtual memory and make sure memory is in physical memory 
d. It is a useless program because the system will not satisfy memory request


if it is linux OS then answer to it is: C
in linux the default VM does overcommit, so malloc 2GB will save some of it in the RAM and all the rest in the VM.

**segfault vs pagefault**
for segfault:

if a CPU trying to access memory for which it does not have permission or invalid it traps with an exception of segmentation fault not pagefault

for pagefault: 

when cpu looking for a page which is not in TLB (temporary look aside buffer) 
then a pagefault occurs which means page need to be loaded back in memory. 

this is done as follows : 
pagefault handler takes care of it , 

it checks if current page is dirty (if date need to be written back to memory using D bit in flags of TLB entry. 

1. first find the location of requested page in page table (PTE which is maintained in software ) 
2. to load that page in TLB (tlb refill occurs depending on archiecture of cpu in MIPS it replaces a random entry and brings requested page. 
3. if cahing is needed do that for current page (check if C flsag was set ) 

return from the handler and execute current instruction.


How many times does "Hello World" get printed?

int main() {
	if (fork() && fork()) {
		fork();
	}
	>> 4 processes here

	if (fork() || fork()) { 
		fork();
	}
	>> 4 more processes for each process
	>> 4  + 4 * 4 = 20

	printf("Hello World");
	return 0;
}

>> 20

fork creates a child process. one pid is 0 and the other is a positive number. In the 2nd if statement, when it calls fork() the pid that is a positive number will short circuit and execute right away. the pid that is 0 needs to evaluate the second fork() in the if statement. 




https://www.quora.com/What-is-difference-between-paging-and-swapping

Swapping is the procedure of copying out the entire process(its address space) from main memory to some sort of secondary storage(typically hard disk or tape storage). Usually this is done as a result of CPU scheduling. 

The most important thing to note here is that the complete process is swapped in/out. There is no granularity over here as to what part of process's address space is swapped back to disk. 



Paging on the other hand is a memory allocation technique that allows the physical address space of the process to be non-contiguous. In other words, a process can be allocated memory wherever it is available and the unit of allocation is the size of page or frame (usually 4KB , but it is system dependent). Wherever a free frame is available in main memory, a physical page belonging to the process can be loaded into it and the page table of process will take care of mapping the logical address (logical page numbers) to correct physical frames in memory (may or may not be contiguous). 


As mentioned in Operating System Concepts (Silberschatz et al.), use of the term swapping is technically incorrect when discussing paging or demand paging. Swapping refers to the manipulation of entire process, where as the latter sees the process as a sequence of pages. Hence, I would like to re-frame my above statement -- 




