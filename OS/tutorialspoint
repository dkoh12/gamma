http://www.tutorialspoint.com/operating_system/

OS: memory management, processor management, device management, file management, security, control over system performance, job accounting, error detecting aids, coordination between other software end users

stack: temp data = func params, return addr, local var
heap: dynamically allocated mem
text: current activity of program counter and contents of processor's registers
data: global / static var


https://gabrieletolomei.wordpress.com/miscellanea/operating-systems/in-memory-layout/


Each process in a multitasking OS runs in its own memory sandbox. This is the virtual address space, which in case of a 32-bit system is always a 4GB block of memory addresses. Indeed, since the smallest unit addressable by the CPU is 1 byte = 8 bit, it turns out that a 32-bit CPU is able to generate up to 2^32 – 1 “numbers”, i.e., addresses each one pointing to a specific byte in memory. These virtual addresses (generated by the CPU) are then mapped to real, physical memory addresses by page tables, which are kept by the operating system kernel. Since the OS kernel is a process itself, it has a dedicated portion of the virtual address space. This is separated from the portion reserved for any other user’s application processes (i.e., not OS processes). For instance, the first 3 GB of virtual addresses (i.e., from 0x00000000 to 0xBFFFFFFF) can be used for user processes while the last 1 GB of virtual addresses (i.e., from 0xC0000000 to 0xFFFFFFFF) are reserved to the OS kernel.






Kernel Mode vs User Mode
Kernel component code executes in a special privileged mode called kernel mode with full access to all resources of the computer. This code represents a single process, executes in single address space and do not require any context switch and hence is very efficient and fast. Kernel runs each processes and provides system services to processes, provides protected access to hardware to processes.

Support code which is not required to run in kernel mode is in System Library. User programs and other system programs works in User Mode which has no access to system hardware and kernel code. User programs/ utilities use System libraries to access Kernel functions to get system's low level tasks.



What is relationship between OS and computer hardware?
Without OS, we cannot access computer hardware. OS makes compter hardware available to application programs.


 How Buffering can improve the performance of a Computer system?

Answer: If C.P.U and I/O devices are nearly same at speed, the buffering helps in making the C.P.U and the I/O devices work at full speed in such a way that C.P.U and the I/O devices never sit idle at any moment.

Normally the C.P.U is much faster than an input device. In this case the C.P.U always faces an empty input buffer and sits idle waiting for the input device which is to read a record into the buffer.For output, the C.P.U continues to work at full speed till the output buffer is full and then it starts waiting.

Thus buffering proves useful for those jobs that have a balance between computational work and I/O operations. In other cases, buffering scheme may not work well.





Difference between a Job and Process?
Process refers to program under execution. Program may be application or system program.
Job means application program not system program.



https://gabrieletolomei.wordpress.com/miscellanea/operating-systems/multiprogramming-multiprocessing-multitasking-multithreading/


Difference between multiprocessing and multiprogramming?

multiprocessing
1. Multiprocessing refers to processing of multiple processes at same time by multiple CPUs.
2. It utilizes multiple CPUs.
3. It permits parallel processing.
4. Less time taken to process the jobs.
5. It facilitates much efficient utilization of devices of the computer system.
6. Usually more expensive.

multiprogramming
1. Multiprogramming keeps several programs in main memory at the same time and execute them concurrently utilizing single CPU.
2. It utilizes single CPU.
3. Context switching takes place.
4. More Time taken to process the jobs.
5. Less efficient than multiprocessing.
6. Such systems are less expensive.


System can be both multiprocessing and multiprogramming




