https://www.tutorialspoint.com/operating_system/os_memory_management.htm

Memory Management

Virtual and physical addresses are same in compile-time and load-time address-binding schemes. virtual and physical addresses differ in execution-time address-binding scheme.

MMU (memory management unit in HW) maps mapping from virtual to physical address
- value in base register is added to every address generated by a user process, which is treated as offset at the time it is sent to memory.
- user program deals with virtual addresses; it never sees the real physical address



At the time of loading, with static loading, the absolute program (and data) is loaded into memory in order for execution to start.

If you are using dynamic loading, dynamic routines of the library are stored on a disk in relocatable form and are loaded into memory only when they are needed by the program.

when static linking is used, the linker combines all other modules needed by a program into a single executable program to avoid any runtime dependency.

When dynamic linking is used, it is not required to link the actual module or library with the program, rather a reference to the dynamic module is provided at the time of compilation and linking. Dynamic Link Libraries (DLL) in Windows and Shared Objects in Unix are good examples of dynamic libraries.


Static linking is the result of the linker copying all library routines used in the program into the executable image. This may require more disk space and memory than dynamic linking, but is both faster and more portable, since it does not require the presence of the library on the system where it is run.

Dynamic linking is accomplished by placing the name of a sharable library in the executable image. Actual linking with the library routines does not occur until the image is run, when both the executable and the library are placed in memory. An advantage of dynamic linking is that multiple programs can share a single copy of the library.



Swapping: mechanism in which a process can be swapped temporarily out of RAM into disk. (and vice versa)

swapping = technique for memory compaction
performance is usually affected by swapping but it helps running multiple and big processes in parallel



Memory Allocation

Main Memory has 2 partitions
* low memory - where OS resides
* high memory - where user processes are held

Single-Partition allocation
relocation-register scheme is used to protect user processes from each other, and from changing operating-system code and data. Relocation register contains value of smallest physical address whereas limit register contains range of logical addresses. Each logical address must be less than the limit register.

Multiple-Partition allocation
main memory is divided into a number of fixed-sized partitions where each partition should contain only one process. When a partition is free, a process is selected from the input queue and is loaded into the free partition. When the process terminates, the partition becomes available for another process.



* **Fragmentation**
- External Fragmentation
	external fragmentation can be reduced by compaction or shuffle memory contents to place all free memory together in one large block. to make compaction feasible, relocation should be dynamic

- Internal Fragmentation
	internal fragmentation can be reduced by effectively assigning the smallest partition but large enough for the process


* **Paging**

process address space broken into blocks of pages (between 512 - 8192 Bytes)
size of process is measured in number of pages
main memory divided into frames. Size of frame = size of page to have optimum utilization of main memory and avoid external fragmentation

page address = logical address
logical address = page number + page offset

frame address = physical address
physical address = frame number + page offset

page table - maps page to frame.

When a process is to be executed, its corresponding pages are loaded into any available memory frames. Suppose you have a program of 8Kb but your memory can accommodate only 5Kb at a given point in time, then the paging concept will come into picture. When a computer runs out of RAM, the operating system (OS) will move idle or unwanted pages of memory to secondary memory to free up RAM for other processes and brings them back when needed by the program.


pro & con
- paging reduces external fragmentation, but still suffers from internal fragmentation
- paging is simple to implement and assumed as an efficient memory management technique
- due to equal size of pages and frames, swapping becomes very easy
- page table requires extra memory space, so may not be good for a system having small RAM


Segmentation

each process (job) is divided into segments of different sizes, one for each module that contains pieces that perform related functions. each segment is actually a different logical address space of the program.

when a process is executed, its corresponding segments are loaded in non-contiguous memory though every segment is loaded into contiguous blocks of available memory

segments are variable length whereas pages are fixed length

OS maintains segment map table for each process and a list of free memory blocks along with segment numbers, their size and corresponding memory locations in main memory.



swapping creates multiple fragments. memory compaction refers to combining all empty spaces together and combining all processes together. disadvantage of memory compaction is that it requires too much CPU time.


memory management using bitmaps. for every allocation unit there is a bit in bitmap. if bit = 0, allocation unit is free. if bit = 1, it is occupied. disadvantage of memory management using bitmaps is that it takes a lot of time to search a bitmap.




Paging vs Segmentation

paging
1. page is a physical unit of information
2. page is invisible to user's program
3. page is of fixed size eg 4KB
4. page size is determined by machine architecture
5. fragmentations may occur
6. page frame on main memory is required

segmentation
1. segment is a logical unit of information
2. segment is visible to user's program
3. segment is of various size
4. segment size is determined by user
5. segmentation eliminates fragmentation
6. no frames are required



Paging: If a certain memory location is not present in RAM then a page fault takes place. This causes the page which contains this memory location to be brought into ram. (Sometimes prefetching can also bring pages into RAM). This way of dealing with memory in terms of pages is called paging. 

Swapping: When the main memory is full and now if there is a page fault, then replacement will take place. The page to be evicted is placed in a backing store (usually dedicated memory on disk). This is swapping. If later this page is needed, it will be reloaded from backing store


